## Рефлексия по предыдущему

В своем подходе я использую три переменные (low, high и mid)
для разделения массива на части, содержащие 0, 1 и 2.
В процессе сортировки элементы я перемещаю на нужные
позиции с помощью функции обмена. Этот подход не требует
дополнительной памяти (за исключением переменных).
Отрабатывает за O(N).

Была мысль использовать императивный алгоритм , но
смутило то, что требуется дополнительный шаг для сортировки 
ключей словаря, возможно это исправило бы использование
списков, которые хранят ключи в отсортированном порядке, например
TreeMap.

Императивный и декларативный подходы легко читаются
и понимаются, что нельзя сказать о моем подходе из-за
дополнительных переменных.
Декларативный подход использует дополнительные списки, 
что требует дополнительной памяти, в императивном же используется
только один дополнительный словарь, что говорит о эффективном 
использовании памяти.
